options
{
    MULTI=true;
    NODE_EXTENDS="MyNode";
    TRACK_TOKENS=true;

    STATIC = false; 
    COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(Minimp)

//import java.util.ArrayList;

public class Minimp
{
  public static int nesting = 0;
  public static int numNewLines = 0;
  //public static boolean indentFlag = false;

  public static ChildrenStack seqAmount = new ChildrenStack();

  public static ChildrenStack funcAmount = new ChildrenStack();

  public static int argAmount=0;

  public static IndentStack indentStack = new IndentStack();

  public Node rootNode()
  {
    return jjtree.rootNode();
  }  

  public static void print_AST(SimpleNode root, String prefix)
  {
    if (root != null) {
      if (root.value != null)
        System.out.println(prefix + root.value);
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          print_AST(n, prefix + "   ");
        }
      }
    }
  }

  public static String print_AST(SimpleNode root)
  {
    String array = prepareArray(root);
    return array.substring(1, array.length());
  }

  public static String prepareArray(SimpleNode root)
  {
    String value = "";
    boolean nonTerminal = false;
    if (root != null) {
      if (root.value != null)
      {
        if(root.jjtGetNumChildren() > 0) 
        {
          //System.out.println(root.value);
          value += " [ ";
          nonTerminal = true;
        }
        value += root.value;
        if(nonTerminal)
        {
          value += " [ ";
        }
      }
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          value += prepareArray(n);
          if (i < root.jjtGetNumChildren()-1)
          {
            value += ", ";
          }
        }
      }
      if (nonTerminal)
      {
        value += " ] ]";
      }
    }
    return value;
  }
}

PARSER_END(Minimp)

TOKEN_MGR_DECLS:
{
    static int indentation[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    static int level = 0;
    static int dedents = 0;
    static int parens = 0;
    static int indent;
    static boolean seen_eof = false;
    static boolean single_input = false;
    static boolean compound = false;
    public static boolean forcedNewline = false;

    static Token addDedent(Token previous) {
        Token t = new Token();
        t.kind = DEDENT;
        t.beginLine = previous.beginLine;
        t.endLine = previous.endLine;
        t.beginColumn = previous.beginColumn;
        t.endColumn = previous.endColumn;
        t.image = "<DEDENT>";
        t.specialToken = null;
        t.next = null;
        previous.next = t;
        return t;
    }

    void CommonTokenAction(Token t) {
        if (t.kind == EOF) {
            //System.out.println("EOF: "+single_input+", "+curLexState);
            if (!single_input) {
                if (curLexState == DEFAULT) {
                    t.kind = NEWLINE;
                }
                else {
                    t.kind = DEDENT;
                    level -= 1;
                }
                while (level-- >= 0)
                    t = addDedent(t);
                //t = addDedent(t);
                t.kind = EOF;
                t.image = "<EOF>";
            }
        }
    }
}

<INDENTING> TOKEN :
{
    <DEDENT: "">
        {
            if (indent > indentation[level]) {
                level++;
                indentation[level] = indent;
                matchedToken.kind=INDENT;
                matchedToken.image = "<INDENT>";
            }
            else {

                Token t = matchedToken;
                level -= 1;
                while (level > 0 && indent < indentation[level]) {
                    level--;
                    t = addDedent(t);
                }
                if (indent != indentation[level]) {
                    //throw new TokenMgrError("inconsistent dedent",
                      //                      t.endLine, t.endColumn);
                  System.out.println("ERROR");
                }
                t.next = null;
            }
        } : DEFAULT
}

SKIP :
{
    <SPACE: " ">
|   "\t"
|   "\014"
|   <CONTINUATION: ("\\") ("\r\n"|"\n"|"\r")>
|   <NEWLINE1: ("\r\n"|"\n"|"\r")>
        {
            if (parens == 0) {
                indent = 0;
                input_stream.backup(1);
                if (level == 0)
                    SwitchTo(FORCE_NEWLINE1);
                else
                    SwitchTo(FORCE_NEWLINE2);
            }
        }
}


<FORCE_NEWLINE1> TOKEN :
{ <NEWLINE: ("\n" | "\r")> : INDENTATION_UNCHANGED }


<FORCE_NEWLINE2> TOKEN :
{ <NEWLINE2: ("\n" | "\r")> { matchedToken.kind = NEWLINE; }: INDENTING }


<FORCE_NEWLINE> TOKEN :
{
    <NEWLINE3: ("\n" | "\r")>
        {
            Token t1 = matchedToken;
            t1.kind = DEDENT;
            while (level-- > 0) 
                t1 = addDedent(t1);
            t1.kind = NEWLINE;
        } : DEFAULT
}

<INDENTING, INDENTATION_UNCHANGED> SKIP :
{
    "\t"
        {
            indent = (indent/8+1)*8;
            if (indent == indentation[level])
                SwitchTo(INDENTATION_UNCHANGED);
            else
                SwitchTo(INDENTING);
        }
        |   " "
        {
            indent += 1;
            if (indent == indentation[level])
                SwitchTo(INDENTATION_UNCHANGED);
            else
                SwitchTo(INDENTING);
        }
        |   "\014"
        {
            indent = 0;
            if (indent == indentation[level])
                SwitchTo(INDENTATION_UNCHANGED);
            else
                SwitchTo(INDENTING);
        }
        |   <CRLF1: ("\r\n" | "\n" | "\r")>
        {

            if (parens == 0 && single_input && indent==0) {
                //System.out.println("force newline");
                //backup a character!
                forcedNewline = true;
                input_stream.backup(1);
                SwitchTo(FORCE_NEWLINE);
            }
            else {
                //doPrompt();
                indent = 0;
                if (indent == indentation[level])
                    SwitchTo(INDENTATION_UNCHANGED);
                else
                    SwitchTo(INDENTING);
            }
        }
}

<INDENTATION_UNCHANGED> SKIP :
{
    <""> : DEFAULT
}

<UNREACHABLE> TOKEN :
{
    < INDENT:"<INDENT>">
//|     < DEDENT:"<DEDENT>">
}

/*SKIP: 
{	
  	  "\r"  
    | "\f"
  	| " "
}*/


/** Programming syntax structuring */
SimpleNode Program() : 
{}
{

    (
       (Statement())
    /*| (Statement() Program())*/
    )*
    //(<NEWLINE>)*
    <EOF>
    { 
      /*System.out.println("list:");
      for(int i = 0; i < indentStack.size(); i++) 
      {
        System.out.println(indentStack.get(i));
      }*/
      return jjtThis;
    }
        
}


void Statement() #void:
{}
{
    (
      DefStatement()
    | IfStatement()
    | ReturnStatement()
    | PrintStatement()
    | WhileStatement()  
    | CallStatement()
    | <NEWLINE>
    )
}


void CallStatement() #void: 
{
  Token t;
}
{     
    /*  LOOKAHEAD(2) 
      AssignmentStatement()
    | FunctionCallStatement()*/  
    
    t=<IDENTIFIER>
    (
      ( Declaration(t) t="=" Expression() 
        {jjtThis.value=t.image;} #equal(2) <NEWLINE>
      )
      |
      (
        {funcAmount.push(0);}
        <LEFTR> ExpressionList() <RIGHTR> <NEWLINE>
        {jjtThis.value=t.image;} #function(funcAmount.peek())
        {funcAmount.pop();}
      )
    )
}


void DefStatement() #void:
{Token t;
 Token n;}
{
    {
      argAmount=0; seqAmount.push(0);
      indentStack.push("def");
    }
    (t="def " n=<IDENTIFIER> <LEFTR> ArgList() <RIGHTR>
    {jjtThis.value=n.image;} #arg_list(argAmount) 
    ":" Sequence()
    {jjtThis.value=t.image;} #def_statement(1+seqAmount.peek()) 
    {argAmount=0; seqAmount.pop();})

}


void ArgList() #void:
{}
{
    ((FuncVariable() MoreArgs() {argAmount++;}) | {})
}


void MoreArgs() #void: 
{}
{
    (("," FuncVariable() MoreArgs() {argAmount++;}) | {})
}


void IfStatement() #void:
{Token t;
 Token n;
 Token a = new Token();
 a.image = "condition";}
{
    {
      seqAmount.push(0);
      indentStack.push("if");
    }
    (t="if " Expression() ":" Sequence() 
      {
        jjtThis.value=t.image;
      } #if_statement(1+seqAmount.peek())
      IndentCopy()
      {
        seqAmount.pop();
        //seqAmount.addToTop();
        seqAmount.push(0);
        indentStack.push("else");
      }
      n="else:" Sequence()
      {
        jjtThis.value=n.image;        
      } #else_statement(seqAmount.peek()))
    {
      seqAmount.pop();
    }
    {jjtThis.value=a.image;} #condition(2)
}


void WhileStatement() #void:
{Token t;}
{
  {
    seqAmount.push(0);
    indentStack.push("while");
  }
  (t="while " Expression() ":" Sequence()
    {jjtThis.value=t.image;} #while_statement(1+seqAmount.peek()))
  {seqAmount.pop();}
}


void ReturnStatement() #void:
{Token t;}
{
    (t="return " Expression() <NEWLINE>
      {jjtThis.value=t.image;} #return_op(1))
}


void PrintStatement() #void:
{Token t;}
{
    (t="print " Expression() 
      {jjtThis.value=t.image;} #print_op(1) 
      <NEWLINE>)
}


/*void AssignmentStatement() #void:
{Token t;}
{
    (Variable() t="=" Expression()
    {jjtThis.value=t.image;} #equal(2) <NEWLINE>)
}*/


void Sequence() #void:
{ Token t; }
{

  /*{
    System.out.println("list:");
    for(int i = 0; i < indentStack.size(); i++) 
    {
      System.out.println(indentStack.get(i));
    }
  }*/
  (<NEWLINE> /*IndentEnter()*/ <INDENT> MoreStatements() <DEDENT>)
    {
      
      /*for(int i = 0; i < indentStack.size(); i++)
      {
        System.out.println("i = " + i + " stack = " + indentStack.get(i));
      }*/ 
      indentStack.pop();

      nesting--;
      int i = nesting;
      while (i > 1)
      {
        Indent(false);
        i--;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());
    }
}

/* 
 * Possible solution for fixing indentation problems, 
 * Keep the stack to identify depth. Create a token for each different depth '\t' '\t\t' ... 
 * Do it for like 5 to 10 depths. Create a call that will based on the stack choose the direction
 * However you would have to compare to each depth up to the current.
 * Example:
 * if you are at depth 2 your next statement could be (under most cases) 0, 1 or 2.
 * 
 * It could go to 3 the next line if indicated by the stack. If the stack adds an element on then the next line must be the depth.
 * Indentation can grown but not strink after an if an else must also follow the if at the same indentation. An else, while def do not have this restriction.
 */
void IndentEnter() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (t=<INDENT> Indent(true)) 
  )
}


void IndentCopy() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (Indent(true)) 
  )
}


void Indent(boolean total) #void:
{
  Token t = null;
}
{
  (
        (t=<INDENT>) 
      | {}
  )
  {
    //Token t;
    if(t != null)
    {
      if(total)
      {
        nesting++;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());

      Indent(total);
    }
    /*else
    {
      if(nesting + 1 == indentStack.size())
      {
        System.out.println("HERE");
        indentFlag = true;
      }
    }*/
  }
}


void MoreStatements() #void:
{}
{
    ( 
      (Statement() {seqAmount.addToTop();} AnotherStatement())
    )
}


void AnotherStatement() #void:
{}
{
    /* Requires the same number of indends as previous */
    /*
     * Essentially, we need to get DEDENT working so that multiple statements can excepted within a single loop, as well.
     */

    (
      LOOKAHEAD(3)
      ( /*IndentEnter()*/ Statement() {seqAmount.addToTop();} AnotherStatement())
    | {}

    )
    {
    //System.out.println("anotherDone");
    }
}


void Expression() #void:
{}
{
    (AdditionalExpression() Comparison())
}


void Comparison() #void:
{Token t;}
{
    (
      (t=<COMPARE> AdditionalExpression() Comparison()
        {jjtThis.value=t.image;} #comp_op(2))
    | {}
    )
}


void AdditionalExpression() #void:
{}
{
    (MultiplicationExpression() AdditionFactor())
}


void AdditionFactor() #void:
{Token t;}
{
    (
      t=<ADDSUB> MultiplicationExpression() AdditionFactor() 
      {jjtThis.value=t.image;} #add_sub_op(2)
    | {}
    )
}


void MultiplicationExpression() #void:
{}
{
    (ElementExpression() MultiplicationFactor())
}


void MultiplicationFactor() #void:
{Token t;}
{
    (
      (t=<MUTLDIV> ElementExpression() MultiplicationFactor()
        {jjtThis.value=t.image;} #mul_div_op(2))
    | {}
    )
}


void ElementExpression() #void:
{}
{
    (PrimitiveExpression() MoreElementAccess())
}


void ElementAccess() #void:
{}
{
    (
      (<LEFTS> Expression() <RIGHTS> MoreElementAccess())
    )
}

void MoreElementAccess() #void:
{}
{
  (
    (<LEFTS> Expression() <RIGHTS> MoreElementAccess())
    | {}
  )
}

void ElementList() #void:
{Token t;}
{
    (
      (<LEFTS> Expression() 
      {
        funcAmount.push(1);
      } 
      MoreExpressions() 
      {jjtThis.value="list";} #list(funcAmount.peek())
      <RIGHTS>)
    )
}

void ExpressionList() #void:
{}
{
    (
      (Expression() {funcAmount.addToTop();} MoreExpressions()) | {}
    )
}


void MoreExpressions() #void:
{}
{
    (
      ("," Expression() {funcAmount.addToTop();} MoreExpressions())
    | {}
    )
}

void FunctionCallStatement() #void:
{Token t;}
{
  // This could be simplified to Not include <INTEGER> as primitive expression
  // Also expression could be removed as well since the only way to properly call a function is through the function's <IDENTIFIER>
  {funcAmount.push(0);}
  (t=<IDENTIFIER>
    (
      (<LEFTR> (ExpressionList()) <RIGHTR>) 
      {jjtThis.value=t.image;} #function(funcAmount.peek())
    | {} Variable(t)
    )
  )
  {funcAmount.pop();}
}

void PrimitiveExpression() #void:
{}
{
    (
      Number()
    | (<LEFTR> Expression() <RIGHTR>)
    | FunctionCallStatement()
    | ElementList()
    )
}

void Number() #Number:
{Token t;}
{
  t=<INTEGER>{jjtThis.value=t.image;}
}

void FuncVariable() #FuncVariable:
{Token t;}
{
  t=<IDENTIFIER>{jjtThis.value=t.image;}
}

void Variable(Token t) #Variable:
{}
{
  {jjtThis.value=t.image;}
}

void Declaration(Token t) #Declaration:
{}
{
  {jjtThis.value=t.image;}
}

TOKEN : /* IDENTIFIERS */
{
      < IDENTIFIER: (<LETTER>|<UNDERSCORE>) (<LETTER>|<DIGIT>|<UNDERSCORE>)* >
    | < #UNDERSCORE: "_" >
    | < #LETTER: [ "a"-"z", "A"-"Z" ] >
    | < #DIGIT: [ "0"-"9"] >
}


TOKEN : /* LITERALS */
{
    <INTEGER: (<DIGIT>)+ >
}


//TOKEN : /* INDENTATION */
//{
    /*  <DEDENT: ~["\t"]> */
/*      <INDENT: "\t">
    | <NEWLINE: "\n">
}*/


TOKEN : /* Comparison */
{
    <COMPARE: ("<"|">"|"<="|">="|"==")>
}


TOKEN : /* MATH */
{
      <ADDSUB: ("+"|"-")>
    | <MUTLDIV: ("*"|"/")>
}


TOKEN : /* BRACKETS */
{
      <LEFTR: "(">
    | <RIGHTR: ")">
    | <LEFTS: "[">
    | <RIGHTS: "]">
}
