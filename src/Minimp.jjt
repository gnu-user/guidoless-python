options
{
    MULTI=true;
    NODE_EXTENDS="MyNode";
    TRACK_TOKENS=true;
}

PARSER_BEGIN(Minimp)

public class Minimp
{
  public static int nesting = 0;
  public static int numNewLines = 0;
  public static int argAmount=0;
  public static int seqAmount=0;

  public Node rootNode()
  {
    return jjtree.rootNode();
  }  

  public static void print_AST(SimpleNode root, String prefix)
  {
    if (root != null) {
      if (root.value != null)
      System.out.println(prefix + root.value);
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          print_AST(n, prefix + "   ");
        }
      }
    }
  }
}

PARSER_END(Minimp)

SKIP: 
{	
  	  "\r"  
    | "\f"
  	| " "
}


/** Programming syntax structuring */
SimpleNode Program() : 
{}
{

    (
       (Statement())
    /*| (Statement() Program())*/
    )*
    (<NEWLINE>)*
    <EOF>
    { return jjtThis;}
        
}


void Statement() #void:
{}
{
    (
      DefStatement()
    | IfStatement()
    | ReturnStatement()
    | PrintStatement()
    | WhileStatement()  
    | CallStatement()
    )
}


void CallStatement() #void: 
{}
{
  
    ( 
      LOOKAHEAD(2) 
      AssignmentStatement()
    | FunctionCallStatement()
    )
}


void DefStatement() #void:
{Token t;
 Token n;}
{
    {argAmount=0; seqAmount=0;}
    (t="def " n=<IDENTIFIER> <LEFTR> ArgList() <RIGHTR>
    {jjtThis.value=n.image;} #arg_list(argAmount) 
    ":" Sequence()
    {jjtThis.value=t.image;} #seq_list(1+seqAmount) 
    {argAmount=0; seqAmount=0;})

}


void ArgList() #void:
{}
{
    ((Variable() MoreArgs() {argAmount++;}) | {})
}


void MoreArgs() #void: 
{}
{
    (("," Variable() MoreArgs() {argAmount++;}) | {})
}


void IfStatement() #void:
{}
{
    ("if " Expression() ":" Sequence() IndentCopy() "else:" Sequence())
}


void WhileStatement() #void:
{}
{
    ("while " Expression() ":" Sequence())
}


void ReturnStatement() #void:
{Token t;}
{
    (t="return " Expression() <NEWLINE>
      {jjtThis.value=t.image;} #return_op(1))
}


void PrintStatement() #void:
{Token t;}
{
    (t="print " Expression() 
      {jjtThis.value=t.image;} #print_op(1) 
      <NEWLINE>)
}


void AssignmentStatement() #void:
{Token t;}
{
    (Variable() t="=" Expression()
    {jjtThis.value=t.image;} #equal(2) <NEWLINE>)
}


void Sequence() #void:
{ Token t; }
{
  (<NEWLINE> IndentEnter() MoreStatements() /*<DEDENT>*/)
    {
      //Token t;
      nesting--;
      int i = nesting;
      while (i > 1)
      {
        Indent(false);
        i--;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());
    }
}


void IndentEnter() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (t=<INDENT> Indent(true)) 
  )
}


void IndentCopy() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (Indent(true)) 
  )
}


void Indent(boolean total) #void:
{
  Token t = null;
}
{
  (
        (t=<INDENT>) 
      | {}
  )
  {
    //Token t;
    if(t != null)
    {
      if(total)
      {
        nesting++;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());

      Indent(total);
    }
  }
}


void MoreStatements() #void:
{}
{
    ( 
      (Statement() {seqAmount++;} AnotherStatement())
    )
}


void AnotherStatement() #void:
{}
{
    /* Requires the same number of indends as previous */
    /*
     * Essentially, we need to get DEDENT working so that multiple statements can excepted within a single loop, as well.
     */
    (
      LOOKAHEAD(3)
      ( IndentEnter() Statement() {seqAmount++;} AnotherStatement())
    | {}

    )
    {
    //System.out.println("anotherDone");
    }
}


void Expression() #void:
{}
{
    (AdditionalExpression() Comparison())
}


void Comparison() #void:
{Token t;}
{
    (
      (t=<COMPARE> AdditionalExpression() Comparison()
        {jjtThis.value=t.image;} #comp_op(2))
    | {}
    )
}


void AdditionalExpression() #void:
{}
{
    (MultiplicationExpression() AdditionFactor())
}


void AdditionFactor() #void:
{Token t;}
{
    (
      t=<ADDSUB> MultiplicationExpression() AdditionFactor() 
      {jjtThis.value=t.image;} #add_sub_op(2)
    | {}
    )
}


void MultiplicationExpression() #void:
{}
{
    (ElementExpression() MultiplicationFactor())
}


void MultiplicationFactor() #void:
{Token t;}
{
    (
      (t=<MUTLDIV> ElementExpression() MultiplicationFactor()
        {jjtThis.value=t.image;} #mul_div_op(2))
    | {}
    )
}


void ElementExpression() #void:
{}
{
    (PrimitiveExpression() ElementAccess())
}


void ElementAccess() #void:
{}
{
    (
      (<LEFTS> Expression() <RIGHTS> ElementAccess())
    | {}
    )
}


void ExpressionList() #void:
{}
{
    (
      (Expression() MoreExpressions())
    | {}
    )
}


void MoreExpressions() #void:
{}
{
    (
      ("," Expression() MoreExpressions())
    | {}
    )
}

void FunctionCallStatement() #void:
{}
{
  // This could be simplified to Not include <INTEGER> as primitive expression
  // Also expression could be removed as well since the only way to properly call a function is through the function's <IDENTIFIER>
  (PrimitiveExpression() <LEFTR> ExpressionList() <RIGHTR> <NEWLINE>)
}

void PrimitiveExpression() #void:
{}
{
    (
      Number()
    | (<LEFTR> Expression() <RIGHTR>)
    | Variable()
    )
}

void Number() #Number:
{Token t;}
{
  t=<INTEGER>{jjtThis.value=t.image;}
}

void Variable() #Variable:
{Token t;}
{
  t=<IDENTIFIER>{jjtThis.value=t.image;}
}


TOKEN : /* IDENTIFIERS */
{
      < IDENTIFIER: (<LETTER>|<UNDERSCORE>) (<LETTER>|<DIGIT>|<UNDERSCORE>)* >
    | < #UNDERSCORE: "_" >
    | < #LETTER: [ "a"-"z", "A"-"Z" ] >
    | < #DIGIT: [ "0"-"9"] >
}


TOKEN : /* LITERALS */
{
    <INTEGER: (<DIGIT>)+ >
}


TOKEN : /* INDENTATION */
{
    /*  <DEDENT: ~["\t"]> */
      <INDENT: "\t">
    | <NEWLINE: "\n">
}


TOKEN : /* Comparison */
{
    <COMPARE: ("<"|">"|"<="|">="|"==")>
}


TOKEN : /* MATH */
{
      <ADDSUB: ("+"|"-")>
    | <MUTLDIV: ("*"|"/")>
}


TOKEN : /* BRACKETS */
{
      <LEFTR: "(">
    | <RIGHTR: ")">
    | <LEFTS: "[">
    | <RIGHTS: "]">
}