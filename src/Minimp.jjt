options
{
    MULTI=true;
    NODE_EXTENDS="MyNode";
    TRACK_TOKENS=true;
}

PARSER_BEGIN(Minimp)

//import java.util.ArrayList;

public class Minimp
{
  public static int nesting = 0;
  public static int numNewLines = 0;

  public static ChildrenStack seqAmount = new ChildrenStack();

  public static ChildrenStack funcAmount = new ChildrenStack();

  public static int argAmount=0;

  public static IndentStack indentStack = new IndentStack();

  public Node rootNode()
  {
    return jjtree.rootNode();
  }  

  public static void print_AST(SimpleNode root, String prefix)
  {
    if (root != null) {
      if (root.value != null)
        System.out.println(prefix + root.value);
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          print_AST(n, prefix + "   ");
        }
      }
    }
  }

  public static String print_AST(SimpleNode root)
  {
    String array = prepareArray(root);
    return array.substring(1, array.length());
  }

  public static String prepareArray(SimpleNode root)
  {
    String value = "";
    boolean nonTerminal = false;
    if (root != null) {
      if (root.value != null)
      {
        if(root.jjtGetNumChildren() > 0) 
        {
          //System.out.println(root.value);
          value += " [ ";
          nonTerminal = true;
        }
        value += root.value;
        if(nonTerminal)
        {
          value += " [ ";
        }
      }
      for (int i = 0; i < root.jjtGetNumChildren(); ++i) {
        SimpleNode n = (SimpleNode)root.jjtGetChild(i);
        if (n != null) {
          value += prepareArray(n);
          if (i < root.jjtGetNumChildren()-1)
          {
            value += ", ";
          }
        }
      }
      if (nonTerminal)
      {
        value += " ] ]";
      }
    }
    return value;
  }
}

PARSER_END(Minimp)

SKIP: 
{	
  	  "\r"  
    | "\f"
  	| " "
}


/** Programming syntax structuring */
SimpleNode Program() : 
{}
{

    (
       (Statement())
    /*| (Statement() Program())*/
    )*
    (<NEWLINE>)*
    <EOF>
    { 
      /*System.out.println("list:");
      for(int i = 0; i < indentStack.size(); i++) 
      {
        System.out.println(indentStack.get(i));
      }*/
      return jjtThis;
    }
        
}


void Statement() #void:
{}
{
    (
      DefStatement()
    | IfStatement()
    | ReturnStatement()
    | PrintStatement()
    | WhileStatement()  
    | CallStatement()
    )
}


void CallStatement() #void: 
{
  Token t;
}
{     
    /*  LOOKAHEAD(2) 
      AssignmentStatement()
    | FunctionCallStatement()*/  
    
    t=<IDENTIFIER>
    (
      ( NewVar(t) t="=" Expression() 
        {jjtThis.value=t.image;} #equal(2) <NEWLINE>
      )
      |
      (
        {funcAmount.push(0);}
        <LEFTR> ExpressionList() <RIGHTR> <NEWLINE>
        {jjtThis.value=t.image;} #function(funcAmount.peek())
        {funcAmount.pop();}
      )
    )
}


void DefStatement() #void:
{Token t;
 Token n;}
{
    {
      argAmount=0; seqAmount.push(0);
      indentStack.push("def");
    }
    (t="def " n=<IDENTIFIER> <LEFTR> ArgList() <RIGHTR>
    {jjtThis.value=n.image;} #arg_list(argAmount) 
    ":" Sequence()
    {jjtThis.value=t.image;} #seq_list(1+seqAmount.peek()) 
    {argAmount=0; seqAmount.pop();})

}


void ArgList() #void:
{}
{
    ((Variable() MoreArgs() {argAmount++;}) | {})
}


void MoreArgs() #void: 
{}
{
    (("," Variable() MoreArgs() {argAmount++;}) | {})
}


void IfStatement() #void:
{Token t;
 Token n;}
{
    {
      seqAmount.push(0);
      indentStack.push("if");
    }
    (t="if " Expression() ":" Sequence() 
      {
        jjtThis.value=t.image;
      } #if_statement(1+seqAmount.peek())
      IndentCopy()
      {
        seqAmount.pop();
        seqAmount.addToTop();
        seqAmount.push(0);
        indentStack.push("else");
      }
      n="else:" Sequence()
      {
        jjtThis.value=n.image;        
      } #else_statement(seqAmount.peek()))
    {
      seqAmount.pop();
    }
}


void WhileStatement() #void:
{Token t;}
{
  {
    seqAmount.push(0);
    indentStack.push("while");
  }
  (t="while " Expression() ":" Sequence()
    {jjtThis.value=t.image;} #while_statement(1+seqAmount.peek()))
  {seqAmount.pop();}
}


void ReturnStatement() #void:
{Token t;}
{
    (t="return " Expression() <NEWLINE>
      {jjtThis.value=t.image;} #return_op(1))
}


void PrintStatement() #void:
{Token t;}
{
    (t="print " Expression() 
      {jjtThis.value=t.image;} #print_op(1) 
      <NEWLINE>)
}


/*void AssignmentStatement() #void:
{Token t;}
{
    (Variable() t="=" Expression()
    {jjtThis.value=t.image;} #equal(2) <NEWLINE>)
}*/


void Sequence() #void:
{ Token t; }
{

  /*{
    System.out.println("list:");
    for(int i = 0; i < indentStack.size(); i++) 
    {
      System.out.println(indentStack.get(i));
    }
  }*/
  (<NEWLINE> IndentEnter() MoreStatements() /*<DEDENT>*/)
    {
      
      /*for(int i = 0; i < indentStack.size(); i++)
      {
        System.out.println("i = " + i + " stack = " + indentStack.get(i));
      }*/
      indentStack.pop();

      nesting--;
      int i = nesting;
      while (i > 1)
      {
        Indent(false);
        i--;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());
    }
}

/* 
 * Possible solution for fixing indentation problems, 
 * Keep the stack to identify depth. Create a token for each different depth '\t' '\t\t' ... 
 * Do it for like 5 to 10 depths. Create a call that will based on the stack choose the direction
 * However you would have to compare to each depth up to the current.
 * Example:
 * if you are at depth 2 your next statement could be (under most cases) 0, 1 or 2.
 * 
 * It could go to 3 the next line if indicated by the stack. If the stack adds an element on then the next line must be the depth.
 * Indentation can grown but not strink after an if an else must also follow the if at the same indentation. An else, while def do not have this restriction.
 */
void IndentEnter() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (t=<INDENT> Indent(true)) 
  )
}


void IndentCopy() #void:
{
  Token t;
}
{
  {
    nesting = 1;
    //System.out.println("nesting = " + nesting);
    //System.out.println("first tab");
  }
  (
      (Indent(true)) 
  )
}


void Indent(boolean total) #void:
{
  Token t = null;
}
{
  (
        (t=<INDENT>) 
      | {}
  )
  {
    //Token t;
    if(t != null)
    {
      if(total)
      {
        nesting++;
      }
      //System.out.println("nesting = " + nesting);
      //System.out.println("token = " + t.toString());

      Indent(total);
    }
  }
}


void MoreStatements() #void:
{}
{
    ( 
      (Statement() {seqAmount.addToTop();} AnotherStatement())
    )
}


void AnotherStatement() #void:
{}
{
    /* Requires the same number of indends as previous */
    /*
     * Essentially, we need to get DEDENT working so that multiple statements can excepted within a single loop, as well.
     */
    (
      LOOKAHEAD(3)
      ( IndentEnter() Statement() {seqAmount.addToTop();} AnotherStatement())
    | {}

    )
    {
    //System.out.println("anotherDone");
    }
}


void Expression() #void:
{}
{
    (AdditionalExpression() Comparison())
}


void Comparison() #void:
{Token t;}
{
    (
      (t=<COMPARE> AdditionalExpression() Comparison()
        {jjtThis.value=t.image;} #comp_op(2))
    | {}
    )
}


void AdditionalExpression() #void:
{}
{
    (MultiplicationExpression() AdditionFactor())
}


void AdditionFactor() #void:
{Token t;}
{
    (
      t=<ADDSUB> MultiplicationExpression() AdditionFactor() 
      {jjtThis.value=t.image;} #add_sub_op(2)
    | {}
    )
}


void MultiplicationExpression() #void:
{}
{
    (ElementExpression() MultiplicationFactor())
}


void MultiplicationFactor() #void:
{Token t;}
{
    (
      (t=<MUTLDIV> ElementExpression() MultiplicationFactor()
        {jjtThis.value=t.image;} #mul_div_op(2))
    | {}
    )
}


void ElementExpression() #void:
{}
{
    (PrimitiveExpression() MoreElementAccess())
}


void ElementAccess() #void:
{}
{
    (
      (<LEFTS> Expression() <RIGHTS> MoreElementAccess())
    )
}

void MoreElementAccess() #void:
{}
{
  (
    (<LEFTS> Expression() <RIGHTS> MoreElementAccess())
    | {}
  )
}

void ElementList() #void:
{Token t;}
{
    (
      (<LEFTS> Expression() 
      {
        funcAmount.push(1);
      } 
      MoreExpressions() 
      {jjtThis.value="list";} #list(funcAmount.peek())
      <RIGHTS>)
    )
}

void ExpressionList() #void:
{}
{
    (
      (Expression() {funcAmount.addToTop();} MoreExpressions())
    )
}


void MoreExpressions() #void:
{}
{
    (
      ("," Expression() {funcAmount.addToTop();} MoreExpressions())
    | {}
    )
}

void FunctionCallStatement() #void:
{Token t;}
{
  // This could be simplified to Not include <INTEGER> as primitive expression
  // Also expression could be removed as well since the only way to properly call a function is through the function's <IDENTIFIER>
  {funcAmount.push(0);}
  (t=<IDENTIFIER> (<LEFTR> ExpressionList() <RIGHTR>)?
     {jjtThis.value=t.image;} #function(funcAmount.peek()) )
  {funcAmount.pop();}
}

void PrimitiveExpression() #void:
{}
{
    (
      Number()
    | (<LEFTR> Expression() <RIGHTR>)
    | FunctionCallStatement()
    | ElementList()
    )
}

void Number() #Number:
{Token t;}
{
  t=<INTEGER>{jjtThis.value=t.image;}
}

Token Variable() #Variable:
{Token t;}
{
  t=<IDENTIFIER>{jjtThis.value=t.image;
    return t;}
}

void NewVar(Token t) #NewVar:
{}
{
  {jjtThis.value=t.image;}
}


TOKEN : /* IDENTIFIERS */
{
      < IDENTIFIER: (<LETTER>|<UNDERSCORE>) (<LETTER>|<DIGIT>|<UNDERSCORE>)* >
    | < #UNDERSCORE: "_" >
    | < #LETTER: [ "a"-"z", "A"-"Z" ] >
    | < #DIGIT: [ "0"-"9"] >
}


TOKEN : /* LITERALS */
{
    <INTEGER: (<DIGIT>)+ >
}


TOKEN : /* INDENTATION */
{
    /*  <DEDENT: ~["\t"]> */
      <INDENT: "\t">
    | <NEWLINE: "\n">
}


TOKEN : /* Comparison */
{
    <COMPARE: ("<"|">"|"<="|">="|"==")>
}


TOKEN : /* MATH */
{
      <ADDSUB: ("+"|"-")>
    | <MUTLDIV: ("*"|"/")>
}


TOKEN : /* BRACKETS */
{
      <LEFTR: "(">
    | <RIGHTR: ")">
    | <LEFTS: "[">
    | <RIGHTS: "]">
}
